# 单例模式
## 饿汉式
在类初始化的时候就创建该类的对象，相对浪费内存空间
demo1 中使用静态方法

demo2 中使用静态代码块的方法

## 懒汉式
在首次使用该类对象的时候创建

demo1 中加了 synchronized 保证线程安全，但是效率低下，实际只需要在首次创建该类对象的时候加锁即可。

demo2 中采用双重检查锁的方式保证线程安全。效率相对demo1中较高，但会由于 JVM 指令重排序的问题导致 空指针异常
故加 volatile 关键字，保证顺序。

demo3 中采用了静态内部类的方式实现单例模式。由于JVM的特性，在加载外部类的时候，不会去加载静态内部类，只有内部类的属性和方法被调用的时候才会去加载，并初始化其内部属性。静态属性由于被static 修饰，保证只被实例化一次，并且严格保证实例化顺序。

**静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费**



## 枚举方式

枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举类是所有单例模式视线中唯一一种不会被破坏的单例实现模式

> ​	public enum Singleton{
>
> ​			INSTANCE;
>
> ​	}

``说明：`` 

​		枚举方式属于恶汉式方式



## 破坏单例模式

### 序列化反序列化破坏单例模式



# 工厂模式
## package simple
### 问题描述
咖啡店跟生产咖啡之间耦合，如果再生产一咖啡，将修改CoffeeStore中的代码，违背“开闭原则”。

## package simple_factory
### 问题描述
解决了咖啡店跟生产咖啡之间的耦合，但是依旧违背“开闭原则”，如果添加一种咖啡，将要修改CoffeeFactory的代码。